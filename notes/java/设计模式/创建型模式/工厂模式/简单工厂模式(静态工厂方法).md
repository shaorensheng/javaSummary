文本内容均是从网络查找，经过自己的理解然后转化为这篇文章。

<a href="#1">简单工厂模式介绍</a></br>
<a href="#3">应用场景</a></br>
<a href="#4">工厂模式分析</a></br>
<a href="#5">代码</a></br>
<a href="#6">优点</a></br>
<a href="#7">缺点</a></br>
<a href="#8">Java中的应用</a></br>
<a href="#9">总结</a></br>

### <a name="1">简单工厂模式介绍</a>

---
简单工厂模式又叫静态工厂模式，并不是23中常用设计模式之一，只算是工厂模式
的一个特殊实现。相比工厂方法模式和抽象工厂模式使用少得多，因为它只适应
一些简单的情况。</br>
在简单工厂模式中，可以根据参数的不同返回不同类的实例。</br>
简单工厂模式专门定义一个类负责创建其他类的实例，呗创建的实例通常都具有共同父类。


### <a name="3">应用场景</a>

---
比如：</br>
    去蛋糕店买一个蛋糕。</br>
    蛋糕店有多种款式的蛋糕供选择。</br>
    买蛋糕的人，只要说出蛋糕的名字，蛋糕店就会拿出一个对应的蛋糕。</br>
    此时蛋糕店就相当于简单工厂模式中的工厂。只需根据用户给出的蛋糕名称去制作对应的蛋糕，
    并且蛋糕的制作过程对买蛋糕的人完全是隐藏的。</br>
    蛋糕的制作过程也基本相似，比如：准备原料、模型、样式制作。。。；
    可能区别也就是有的蛋糕有巧克力，有的没有；有的蛋糕为圆的，有的为方的。。。
</br>
![简单工厂模式](img/简单工厂模式.jpg)
### <a name="4">工厂模式分析</a>

---
### <a name="5">优点</a>

---
* 解耦
* 降低代码重复
* 降低维护成本
### <a name="6">缺点</a>

---

* 由于工厂类集中了所有的创建逻辑，一旦不能正常工作，整个系统都会受到影响。
* 使用简单工厂模式将会增加系统中类的个数，在一定程度上增加了系统的复杂度和理解难度。
* 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，
有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。
* 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。
### <a name="7">代码</a>

---
* 基类 
```
蛋糕类
public interface Cake {

    /**
     * 原料
     */
    public void getMaterial();

    /**
     * 形状
     */
    public void getShape();

    /**
     * 样式
     */
    public void getStyle();
}
```
* 子类
```
水果蛋糕类
public class FruitsCake implements Cake {
    @Override
    public void getMaterial() {
        System.out.println("水果");
    }

    @Override
    public void getShape() {
        System.out.println("方形");
    }

    @Override
    public void getStyle() {
        System.out.println("九宫格");
    }

    @Override
    public String toString() {
        getMaterial();
        getShape();
        getStyle();
        return "水果蛋糕";
    }
}
```
```
巧克力蛋糕
public class ChocolateCake implements Cake {
    @Override
    public void getMaterial() {
        System.out.println("巧克力");
    }

    @Override
    public void getShape() {
        System.out.println("圆形");
    }

    @Override
    public void getStyle() {
        System.out.println("花");
    }

    @Override
    public String toString() {
        getMaterial();
        getShape();
        getStyle();
        return "巧克力蛋糕";
    }
}
```
```
咩咩羊蛋糕
public class SheepCake implements Cake {
    @Override
    public void getMaterial() {
        System.out.println("巧克力");
    }

    @Override
    public void getShape() {
        System.out.println("圆形");
    }

    @Override
    public void getStyle() {
        System.out.println("羊");
    }

    @Override
    public String toString() {
        getMaterial();
        getShape();
        getStyle();
        return "咩咩羊蛋糕";
    }
}

```
* 工厂类
```
蛋糕店
public class CakeFactory {
    public static Cake createCake(String cakeName){
        Cake cake = null;
        switch (cakeName){
            case "巧克力蛋糕":
                cake = new ChocolateCake();
                break;
            case "水果蛋糕":
                cake = new FruitsCake();
                break;
            case "咩咩羊蛋糕":
                cake = new SheepCake();
                break;
        }
        return cake;
    }

}
```
* 消费
```
客户
public class Customer {
    /**
     * 买蛋糕
     * @param cakeName
     * @return
     */
    public Cake buyCake(String cakeName){
        return CakeFactory.createCake(cakeName);
    }

    public static void main(String[] args) throws ParseException {
        Customer customer = new Customer();
        Cake cake = customer.buyCake("巧克力蛋糕");
        System.out.println("顾客买到了"+cake.toString());
    }

}
```
### <a name="8">Java中的应用</a>

---
1、工具类java.text.DateFormat，用于格式化一个本地日期或者时间
```
public final static DateFormat getDateInstance();
public final static DateFormat getDateInstance(int style);
public final static DateFormat getDateInstance(int style,Localelocale);
```
2、加密技术
```
KeyGenerator keyGen=KeyGenerator.getInstance("DESede");
```
### <a name="9">总结</a>

---





